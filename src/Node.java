import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.util.List;
import java.util.Random;

import javax.crypto.Mac;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Super class represents server or client to build tls
 * 
 * @author qiliu
 *
 */
public abstract class Node {
	
	protected ObjectInputStream in;
	protected ObjectOutputStream out;
	protected int port;
	
	protected byte[] nonce; // nonce that sent from client
	protected int randomPrivateKey; // the private key that the node computed based on two public prime numbers
	protected BigInteger DHPublicKey; // a public key computed with two public prime numbers
	protected BigInteger receivedDHPublicKey; // a public key received from another node
	protected BigInteger secretKey; // a shared secret key computed by each node
	protected PrivateKey privateKey; // private key generated by certificate
	protected Certificate cert; // the signed certificate of this node
	protected boolean authenticateServer;
	protected boolean clientAuthenticated;
	protected ByteArrayOutputStream currentAllMessages; // a byteArrayOutputstream that record all handshake messages
	//protected List<byte[]> sessionKeys; // 6 derived session keys
	protected byte[] macedMessages;
	protected boolean handshakeFinished;
	
	protected Mac serverMacKey; 
	protected SecretKeySpec serverSKey; 
	protected IvParameterSpec serverIV; 
	protected Mac clientMacKey; 
	protected SecretKeySpec clientSKey; 
	protected IvParameterSpec clientIV; 


	public Node(String privateKeyName, String signedCertificateName) throws NoSuchAlgorithmException {
		Random r = new Random();
		nonce = new byte[32];
		this.randomPrivateKey = r.nextInt(2000) + 1;
		DHPublicKey = Handshake.getDHPublicKey(randomPrivateKey);
		privateKey = Handshake.getPrivateKey(privateKeyName);
		cert = Handshake.getCertificate(signedCertificateName);
		in = null;
		out = null;
		port = 9876;
		//sessionKeys = new ArrayList<>();
		this.currentAllMessages = new ByteArrayOutputStream();
		
		this.serverMacKey = Mac.getInstance("HmacSHA256");
		this.clientMacKey = Mac.getInstance("HmacSHA256");
	}

	/**
	 * The node send all authenticate info to another node (either server to client
	 * or client to server)
	 */
	public void sendAuthenticationInfoAndGetAuthenticated() {
		byte[] signedDHPublicKey = Handshake.signDHPublicKey(this.privateKey, DHPublicKey);
		try {
			this.currentAllMessages.write(this.cert.getEncoded());
			this.currentAllMessages.write(DHPublicKey.toByteArray());
			this.currentAllMessages.write(signedDHPublicKey);
			Handshake.sendVerificationInfo(out, this.cert, DHPublicKey, signedDHPublicKey);

		} catch (CertificateEncodingException | IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * Read the public key from node to compute the shared secret key and send
	 * computed public key to node
	 */
	public void computeSharedSecretKey() {
		this.secretKey = Handshake.getSharedSecretKey(this.randomPrivateKey, this.receivedDHPublicKey);
	}

	/**
	 * derive 6 session keys
	 * @throws NoSuchAlgorithmException 
	 * @throws InvalidKeyException 
	 */
	public void deriveSessionKeys() throws InvalidKeyException{
		List<byte[]> keys = KeyGeneration.makeSecretKeys(nonce, secretKey);
		this.serverMacKey.init(new SecretKeySpec(keys.get(2), "HmacSHA256"));
		this.clientMacKey.init(new SecretKeySpec(keys.get(3), "HmacSHA256"));
		this.serverSKey = new SecretKeySpec(keys.get(0), "AES");
		this.clientSKey = new SecretKeySpec(keys.get(1), "AES");
		this.serverIV =  new IvParameterSpec(keys.get(4));
		this.clientIV =  new IvParameterSpec(keys.get(5));
	}
	
	

}
